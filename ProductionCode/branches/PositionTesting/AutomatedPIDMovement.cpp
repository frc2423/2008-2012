/**	\file 		AutomatedPIDMovement.cpp	\author 	Dustin Spicuzza: last changed by $Author: dspicuzz $	\date 		Last changed on $Date: 2009-01-30 01:53:08 -0500 (Fri, 30 Jan 2009) $	\version 	$Rev: 71 $*/#include <WPILib.h>#include "AutomatedPIDMovement.h"AutomatedPIDMovement::AutomatedPIDMovement(KwarqsDriveController * driveController) :	KwarqsMovementControl(driveController),	m_heading_pid(0.1F, 0.0F, 0.0F, &m_pid_interface, &m_pid_interface){	m_heading_pid.SetContinuous();	m_heading_pid.SetInputRange(0, 360);	m_heading_pid.SetOutputRange(-360, 360);		m_positionInfo = PositionInformation::GetInstance();}void AutomatedPIDMovement::OnEnable(){	// set things up	m_destination_idx = 0;		// call move to set things up	Move();		// enable the PID controller	m_heading_pid.Enable();}void AutomatedPIDMovement::OnDisable(){	// disable the PID controller	m_heading_pid.Disable();}void AutomatedPIDMovement::Move(){	// no longer moving, we've reached the end of our journey	if (m_destination_idx >= m_path.size())		return;		// get our current x and y coordinates	double current_x = 0, current_y = 0;	m_positionInfo->GetPosition(current_x, current_y);	// get x and y of where we're going	double x = m_path[m_destination_idx].x - current_x;	double y = m_path[m_destination_idx].y - current_y;		// have we arrived? (within .5 meters)	if ( fabs(x) < 0.5 && fabs(y) < 0.5)	{		printf("Arrived at destination %d (%.3f , %.3f) -- currently at %.3f, %.3f\n", 			m_destination_idx, 			m_path[m_destination_idx].x, m_path[m_destination_idx].y,			current_x, current_y);				// calculate a new path to our destination		if (++m_destination_idx >= m_path.size())		{			m_heading_pid.Disable();				m_driveController->Move(0, 0);					printf("At final destination\n");			return;		}				// recalculate the path to our destination		x = m_path[m_destination_idx].x - current_x;		y = m_path[m_destination_idx].y - current_y;	}		// calculate speed as a function of distance	double speed = sqrt( x*x + y*y );		if (speed > 3.0)		speed = 3.0;			// scale to 0 to 1 linearly (this of course is bad, but works for now)	speed = speed / 3.0;		// where do we need to go?	double angle = (atan2(y, x) * (180/M_PI) - 90.0 ) * -1;	if (angle < 0) angle += 360;		// tell the pid controller where we're going	m_heading_pid.SetSetpoint(angle);		// calculate the rate of turn from the pid output	double rate_of_turn = m_pid_interface.m_output;		// scale it to full turning speed over 180 degrees, progressively less 	if (rate_of_turn > 180)		rate_of_turn = 180.0;	else if (rate_of_turn < -180)		rate_of_turn = -180.0;			rate_of_turn = rate_of_turn / 180.0;		// allow some error	if (fabs(rate_of_turn) < 0.05)		rate_of_turn = 0.0;		// ok, set the parameters and we're done	m_driveController->Move( speed, rate_of_turn );}